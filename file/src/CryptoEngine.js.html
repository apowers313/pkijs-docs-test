<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/CryptoEngine.js | pkijs</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Public Key Infrastructure (PKI) is the basis of how identity and key management is performed on the web today. PKIjs is a pure JavaScript library implementing the formats that are used in PKI applications. It is built on WebCrypto and aspires to make it possible to build native web applications that utilize X.509 and the related formats on the web without plug-ins"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="pkijs"><meta property="twitter:description" content="Public Key Infrastructure (PKI) is the basis of how identity and key management is performed on the web today. PKIjs is a pure JavaScript library implementing the formats that are used in PKI applications. It is built on WebCrypto and aspires to make it possible to build native web applications that utilize X.509 and the related formats on the web without plug-ins"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AccessDescription.js~AccessDescription.html">AccessDescription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Accuracy.js~Accuracy.html">Accuracy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AlgorithmIdentifier.js~AlgorithmIdentifier.html">AlgorithmIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AltName.js~AltName.html">AltName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Attribute.js~Attribute.html">Attribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV1.js~AttCertValidityPeriod.html">AttCertValidityPeriod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV1.js~AttributeCertificateInfoV1.html">AttributeCertificateInfoV1</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV1.js~AttributeCertificateV1.html">AttributeCertificateV1</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV1.js~IssuerSerial.html">IssuerSerial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV2.js~AttributeCertificateInfoV2.html">AttributeCertificateInfoV2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV2.js~AttributeCertificateV2.html">AttributeCertificateV2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV2.js~Holder.html">Holder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV2.js~ObjectDigestInfo.html">ObjectDigestInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeCertificateV2.js~V2Form.html">V2Form</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AttributeTypeAndValue.js~AttributeTypeAndValue.html">AttributeTypeAndValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AuthenticatedSafe.js~AuthenticatedSafe.html">AuthenticatedSafe</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/AuthorityKeyIdentifier.js~AuthorityKeyIdentifier.html">AuthorityKeyIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/BasicConstraints.js~BasicConstraints.html">BasicConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/BasicOCSPResponse.js~BasicOCSPResponse.html">BasicOCSPResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CRLBag.js~CRLBag.html">CRLBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CRLDistributionPoints.js~CRLDistributionPoints.html">CRLDistributionPoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertBag.js~CertBag.html">CertBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertID.js~CertID.html">CertID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Certificate.js~Certificate.html">Certificate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertificateChainValidationEngine.js~CertificateChainValidationEngine.html">CertificateChainValidationEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertificatePolicies.js~CertificatePolicies.html">CertificatePolicies</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertificateRevocationList.js~CertificateRevocationList.html">CertificateRevocationList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertificateSet.js~CertificateSet.html">CertificateSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CertificationRequest.js~CertificationRequest.html">CertificationRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ContentInfo.js~ContentInfo.html">ContentInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CryptoEngine.js~CryptoEngine.html">CryptoEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DigestInfo.js~DigestInfo.html">DigestInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DistributionPoint.js~DistributionPoint.html">DistributionPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ECCCMSSharedInfo.js~ECCCMSSharedInfo.html">ECCCMSSharedInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ECPrivateKey.js~ECPrivateKey.html">ECPrivateKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ECPublicKey.js~ECPublicKey.html">ECPublicKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/EncapsulatedContentInfo.js~EncapsulatedContentInfo.html">EncapsulatedContentInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/EncryptedContentInfo.js~EncryptedContentInfo.html">EncryptedContentInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/EncryptedData.js~EncryptedData.html">EncryptedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/EnvelopedData.js~EnvelopedData.html">EnvelopedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ExtKeyUsage.js~ExtKeyUsage.html">ExtKeyUsage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Extension.js~Extension.html">Extension</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Extensions.js~Extensions.html">Extensions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/GeneralName.js~GeneralName.html">GeneralName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/GeneralNames.js~GeneralNames.html">GeneralNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/GeneralSubtree.js~GeneralSubtree.html">GeneralSubtree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/InfoAccess.js~InfoAccess.html">InfoAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/IssuerAndSerialNumber.js~IssuerAndSerialNumber.html">IssuerAndSerialNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/IssuingDistributionPoint.js~IssuingDistributionPoint.html">IssuingDistributionPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KEKIdentifier.js~KEKIdentifier.html">KEKIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KEKRecipientInfo.js~KEKRecipientInfo.html">KEKRecipientInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KeyAgreeRecipientIdentifier.js~KeyAgreeRecipientIdentifier.html">KeyAgreeRecipientIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KeyAgreeRecipientInfo.js~KeyAgreeRecipientInfo.html">KeyAgreeRecipientInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KeyBag.js~KeyBag.html">KeyBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/KeyTransRecipientInfo.js~KeyTransRecipientInfo.html">KeyTransRecipientInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MacData.js~MacData.html">MacData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MessageImprint.js~MessageImprint.html">MessageImprint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/NameConstraints.js~NameConstraints.html">NameConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OCSPRequest.js~OCSPRequest.html">OCSPRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OCSPResponse.js~OCSPResponse.html">OCSPResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OriginatorIdentifierOrKey.js~OriginatorIdentifierOrKey.html">OriginatorIdentifierOrKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OriginatorInfo.js~OriginatorInfo.html">OriginatorInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OriginatorPublicKey.js~OriginatorPublicKey.html">OriginatorPublicKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OtherCertificateFormat.js~OtherCertificateFormat.html">OtherCertificateFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OtherKeyAttribute.js~OtherKeyAttribute.html">OtherKeyAttribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OtherPrimeInfo.js~OtherPrimeInfo.html">OtherPrimeInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OtherRecipientInfo.js~OtherRecipientInfo.html">OtherRecipientInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/OtherRevocationInfoFormat.js~OtherRevocationInfoFormat.html">OtherRevocationInfoFormat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PBES2Params.js~PBES2Params.html">PBES2Params</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PBKDF2Params.js~PBKDF2Params.html">PBKDF2Params</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PFX.js~PFX.html">PFX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PKCS8ShroudedKeyBag.js~PKCS8ShroudedKeyBag.html">PKCS8ShroudedKeyBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PKIStatusInfo.js~PKIStatusInfo.html">PKIStatusInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PasswordRecipientinfo.js~PasswordRecipientinfo.html">PasswordRecipientinfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PolicyConstraints.js~PolicyConstraints.html">PolicyConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PolicyInformation.js~PolicyInformation.html">PolicyInformation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PolicyMapping.js~PolicyMapping.html">PolicyMapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PolicyMappings.js~PolicyMappings.html">PolicyMappings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PolicyQualifierInfo.js~PolicyQualifierInfo.html">PolicyQualifierInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrivateKeyInfo.js~PrivateKeyInfo.html">PrivateKeyInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PrivateKeyUsagePeriod.js~PrivateKeyUsagePeriod.html">PrivateKeyUsagePeriod</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/PublicKeyInfo.js~PublicKeyInfo.html">PublicKeyInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RSAESOAEPParams.js~RSAESOAEPParams.html">RSAESOAEPParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RSAPrivateKey.js~RSAPrivateKey.html">RSAPrivateKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RSAPublicKey.js~RSAPublicKey.html">RSAPublicKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RSASSAPSSParams.js~RSASSAPSSParams.html">RSASSAPSSParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RecipientEncryptedKey.js~RecipientEncryptedKey.html">RecipientEncryptedKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RecipientEncryptedKeys.js~RecipientEncryptedKeys.html">RecipientEncryptedKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RecipientIdentifier.js~RecipientIdentifier.html">RecipientIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RecipientInfo.js~RecipientInfo.html">RecipientInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RecipientKeyIdentifier.js~RecipientKeyIdentifier.html">RecipientKeyIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RelativeDistinguishedNames.js~RelativeDistinguishedNames.html">RelativeDistinguishedNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ResponseBytes.js~ResponseBytes.html">ResponseBytes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ResponseData.js~ResponseData.html">ResponseData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RevocationInfoChoices.js~RevocationInfoChoices.html">RevocationInfoChoices</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/RevokedCertificate.js~RevokedCertificate.html">RevokedCertificate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SafeBag.js~SafeBag.html">SafeBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SafeContents.js~SafeContents.html">SafeContents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SecretBag.js~SecretBag.html">SecretBag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Signature.js~Signature.html">Signature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SignedAndUnsignedAttributes.js~SignedAndUnsignedAttributes.html">SignedAndUnsignedAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SignedCertificateTimestampList.js~SignedCertificateTimestamp.html">SignedCertificateTimestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SignedCertificateTimestampList.js~SignedCertificateTimestampList.html">SignedCertificateTimestampList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SignedData.js~SignedData.html">SignedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SignerInfo.js~SignerInfo.html">SignerInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SingleResponse.js~SingleResponse.html">SingleResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/SubjectDirectoryAttributes.js~SubjectDirectoryAttributes.html">SubjectDirectoryAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TBSRequest.js~TBSRequest.html">TBSRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TSTInfo.js~TSTInfo.html">TSTInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Time.js~Time.html">Time</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TimeStampReq.js~TimeStampReq.html">TimeStampReq</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TimeStampResp.js~TimeStampResp.html">TimeStampResp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-verifySCTsForCertificate">verifySCTsForCertificate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCMSECDSASignature">createCMSECDSASignature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createECDSASignatureFromCMS">createECDSASignatureFromCMS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAlgorithmByOID">getAlgorithmByOID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAlgorithmParameters">getAlgorithmParameters</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getCrypto">getCrypto</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngine">getEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getHashAlgorithm">getHashAlgorithm</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getOIDByAlgorithm">getOIDByAlgorithm</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getRandomValues">getRandomValues</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-kdf">kdf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-kdfWithCounter">kdfWithCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setEngine">setEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringPrep">stringPrep</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/CryptoEngine.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as asn1js from &quot;asn1js&quot;;
import { getParametersValue, stringToArrayBuffer, arrayBufferToString, utilConcatBuf } from &quot;pvutils&quot;;
import { createCMSECDSASignature, createECDSASignatureFromCMS } from &quot;./common.js&quot;;
import PublicKeyInfo from &quot;./PublicKeyInfo.js&quot;;
import PrivateKeyInfo from &quot;./PrivateKeyInfo.js&quot;;
import AlgorithmIdentifier from &quot;./AlgorithmIdentifier.js&quot;;
import EncryptedContentInfo from &quot;./EncryptedContentInfo.js&quot;;
import RSASSAPSSParams from &quot;./RSASSAPSSParams.js&quot;;
import PBKDF2Params from &quot;./PBKDF2Params.js&quot;;
import PBES2Params from &quot;./PBES2Params.js&quot;;
//**************************************************************************************
/**
 * Making MAC key using algorithm described in B.2 of PKCS#12 standard.
 */
function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount)
{
	//region Initial variables
	let u;
	let v;
	
	const result = [];
	//endregion
	
	//region Get &quot;u&quot; and &quot;v&quot; values
	switch(hashAlgorithm.toUpperCase())
	{
		case &quot;SHA-1&quot;:
			u = 20; // 160
			v = 64; // 512
			break;
		case &quot;SHA-256&quot;:
			u = 32; // 256
			v = 64; // 512
			break;
		case &quot;SHA-384&quot;:
			u = 48; // 384
			v = 128; // 1024
			break;
		case &quot;SHA-512&quot;:
			u = 64; // 512
			v = 128; // 1024
			break;
		default:
			throw new Error(&quot;Unsupported hashing algorithm&quot;);
	}
	//endregion
	
	//region Main algorithm making key
	//region Transform password to UTF-8 like string
	const passwordViewInitial = new Uint8Array(password);
	
	const passwordTransformed = new ArrayBuffer((password.byteLength * 2) + 2);
	const passwordTransformedView = new Uint8Array(passwordTransformed);
	
	for(let i = 0; i &lt; passwordViewInitial.length; i++)
	{
		passwordTransformedView[i * 2] = 0x00;
		passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
	}
	
	passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
	passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
	
	password = passwordTransformed.slice(0);
	//endregion
	
	//region Construct a string D (the &quot;diversifier&quot;) by concatenating v/8 copies of ID
	const D = new ArrayBuffer(v);
	const dView = new Uint8Array(D);
	
	for(let i = 0; i &lt; D.byteLength; i++)
		dView[i] = 3; // The ID value equal to &quot;3&quot; for MACing (see B.3 of standard)
	//endregion
	
	//region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)
	const saltLength = salt.byteLength;
	
	const sLen = v * Math.ceil(saltLength / v);
	const S = new ArrayBuffer(sLen);
	const sView = new Uint8Array(S);
	
	const saltView = new Uint8Array(salt);
	
	for(let i = 0; i &lt; sLen; i++)
		sView[i] = saltView[i % saltLength];
	//endregion
	
	//region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)
	const passwordLength = password.byteLength;
	
	const pLen = v * Math.ceil(passwordLength / v);
	const P = new ArrayBuffer(pLen);
	const pView = new Uint8Array(P);
	
	const passwordView = new Uint8Array(password);
	
	for(let i = 0; i &lt; pLen; i++)
		pView[i] = passwordView[i % passwordLength];
	//endregion
	
	//region Set I=S||P to be the concatenation of S and P
	const sPlusPLength = S.byteLength + P.byteLength;
	
	let I = new ArrayBuffer(sPlusPLength);
	let iView = new Uint8Array(I);
	
	iView.set(sView);
	iView.set(pView, sView.length);
	//endregion
	
	//region Set c=ceil(n / u)
	const c = Math.ceil((keyLength &gt;&gt; 3) / u);
	//endregion
	
	//region Initial variables
	let internalSequence = Promise.resolve(I);
	//endregion
	
	//region For i=1, 2, ..., c, do the following:
	for(let i = 0; i &lt;= c; i++)
	{
		internalSequence = internalSequence.then(_I =&gt;
		{
			//region Create contecanetion of D and I
			const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
			const dAndIView = new Uint8Array(dAndI);
			
			dAndIView.set(dView);
			dAndIView.set(iView, dView.length);
			//endregion
			
			return dAndI;
		});
		
		//region Make &quot;iterationCount&quot; rounds of hashing
		for(let j = 0; j &lt; iterationCount; j++)
			internalSequence = internalSequence.then(roundBuffer =&gt; cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
		//endregion
		
		internalSequence = internalSequence.then(roundBuffer =&gt;
		{
			//region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)
			const B = new ArrayBuffer(v);
			const bView = new Uint8Array(B);
			
			for(let j = 0; j &lt; B.byteLength; j++)
				bView[j] = roundBuffer[j % roundBuffer.length];
			//endregion
			
			//region Make new I value
			const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
			const iRound = [];
			
			let sliceStart = 0;
			let sliceLength = v;
			
			for(let j = 0; j &lt; k; j++)
			{
				const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
				sliceStart += v;
				if((sliceStart + v) &gt; I.byteLength)
					sliceLength = I.byteLength - sliceStart;
				
				let x = 0x1ff;
				
				for(let l = (B.byteLength - 1); l &gt;= 0; l--)
				{
					x &gt;&gt;= 8;
					x += bView[l] + chunk[l];
					chunk[l] = (x &amp; 0xff);
				}
				
				iRound.push(...chunk);
			}
			
			I = new ArrayBuffer(iRound.length);
			iView = new Uint8Array(I);
			
			iView.set(iRound);
			//endregion
			
			result.push(...(new Uint8Array(roundBuffer)));
			
			return I;
		});
	}
	//endregion
	
	//region Initialize final key
	internalSequence = internalSequence.then(() =&gt;
	{
		const resultBuffer = new ArrayBuffer(keyLength &gt;&gt; 3);
		const resultView = new Uint8Array(resultBuffer);
		
		resultView.set((new Uint8Array(result)).slice(0, keyLength &gt;&gt; 3));
		
		return resultBuffer;
	});
	//endregion
	//endregion
	
	return internalSequence;
}
//**************************************************************************************
/**
 * Default cryptographic engine for Web Cryptography API
 */
export default class CryptoEngine
{
	//**********************************************************************************
	/**
	 * Constructor for CryptoEngine class
	 * @param {Object} [parameters={}]
	 * @property {Object} [schema] asn1js parsed value
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Object}
		 * @description Usually here we are expecting &quot;window.crypto&quot; or an equivalent from custom &quot;crypto engine&quot;
		 */
		this.crypto = getParametersValue(parameters, &quot;crypto&quot;, {});
		/**
		 * @type {Object}
		 * @description Usually here we are expecting &quot;window.crypto.subtle&quot; or an equivalent from custom &quot;crypto engine&quot;
		 */
		this.subtle = getParametersValue(parameters, &quot;subtle&quot;, {});
		/**
		 * @type {string}
		 * @description Name of the &quot;crypto engine&quot;
		 */
		this.name = getParametersValue(parameters, &quot;name&quot;, &quot;&quot;);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Import WebCrypto keys from different formats
	 * @param {string} format
	 * @param {ArrayBuffer|Uint8Array} keyData
	 * @param {Object} algorithm
	 * @param {boolean} extractable
	 * @param {Array} keyUsages
	 * @returns {Promise}
	 */
	importKey(format, keyData, algorithm, extractable, keyUsages)
	{
		//region Initial variables
		let jwk = {};
		//endregion
		
		//region Change &quot;keyData&quot; type if needed
		if(keyData instanceof Uint8Array)
			keyData = keyData.buffer;
		//endregion
		
		switch(format.toLowerCase())
		{
			case &quot;raw&quot;:
				return this.subtle.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages);
			case &quot;spki&quot;:
				{
					const asn1 = asn1js.fromBER(keyData);
					if(asn1.offset === (-1))
						return Promise.reject(&quot;Incorrect keyData&quot;);

					const publicKeyInfo = new PublicKeyInfo();
					try
					{
						publicKeyInfo.fromSchema(asn1.result);
					}
					catch(ex)
					{
						return Promise.reject(&quot;Incorrect keyData&quot;);
					}


					// noinspection FallThroughInSwitchStatementJS
					switch(algorithm.name.toUpperCase())
					{
						case &quot;RSA-PSS&quot;:
							{
								//region Get information about used hash function
								switch(algorithm.hash.name.toUpperCase())
								{
									case &quot;SHA-1&quot;:
										jwk.alg = &quot;PS1&quot;;
										break;
									case &quot;SHA-256&quot;:
										jwk.alg = &quot;PS256&quot;;
										break;
									case &quot;SHA-384&quot;:
										jwk.alg = &quot;PS384&quot;;
										break;
									case &quot;SHA-512&quot;:
										jwk.alg = &quot;PS512&quot;;
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
							// break omitted
						case &quot;RSASSA-PKCS1-V1_5&quot;:
							{
								keyUsages = [&quot;verify&quot;]; // Override existing keyUsages value since the key is a public key

								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								if(publicKeyInfo.algorithm.algorithmId !== &quot;1.2.840.113549.1.1.1&quot;)
									return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);

								//region Get information about used hash function
								if((&quot;alg&quot; in jwk) === false)
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RS1&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RS256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RS384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RS512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
									}
								}
								//endregion

								//region Create RSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						case &quot;ECDSA&quot;:
							keyUsages = [&quot;verify&quot;]; // Override existing keyUsages value since the key is a public key
							// break omitted
						case &quot;ECDH&quot;:
							{
								//region Initial variables
								jwk = {
									kty: &quot;EC&quot;,
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about algorithm
								if(publicKeyInfo.algorithm.algorithmId !== &quot;1.2.840.10045.2.1&quot;)
									return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						case &quot;RSA-OAEP&quot;:
							{
								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								
								if(this.name.toLowerCase() === &quot;safari&quot;)
									jwk.alg = &quot;RSA-OAEP&quot;;
								else
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RSA-OAEP&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RSA-OAEP-256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RSA-OAEP-384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RSA-OAEP-512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
									}
								}
								
								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();
								
								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case &quot;pkcs8&quot;:
				{
					const privateKeyInfo = new PrivateKeyInfo();

					//region Parse &quot;PrivateKeyInfo&quot; object
					const asn1 = asn1js.fromBER(keyData);
					if(asn1.offset === (-1))
						return Promise.reject(&quot;Incorrect keyData&quot;);

					try
					{
						privateKeyInfo.fromSchema(asn1.result);
					}
					catch(ex)
					{
						return Promise.reject(&quot;Incorrect keyData&quot;);
					}
					
					if((&quot;parsedKey&quot; in privateKeyInfo) === false)
						return Promise.reject(&quot;Incorrect keyData&quot;);
					//endregion

					// noinspection FallThroughInSwitchStatementJS
					// noinspection FallThroughInSwitchStatementJS
					switch(algorithm.name.toUpperCase())
					{
						case &quot;RSA-PSS&quot;:
							{
								//region Get information about used hash function
								switch(algorithm.hash.name.toUpperCase())
								{
									case &quot;SHA-1&quot;:
										jwk.alg = &quot;PS1&quot;;
										break;
									case &quot;SHA-256&quot;:
										jwk.alg = &quot;PS256&quot;;
										break;
									case &quot;SHA-384&quot;:
										jwk.alg = &quot;PS384&quot;;
										break;
									case &quot;SHA-512&quot;:
										jwk.alg = &quot;PS512&quot;;
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
							// break omitted
						case &quot;RSASSA-PKCS1-V1_5&quot;:
							{
								keyUsages = [&quot;sign&quot;]; // Override existing keyUsages value since the key is a private key

								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								//region Get information about used hash function
								if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== &quot;1.2.840.113549.1.1.1&quot;)
									return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Get information about used hash function
								if((&quot;alg&quot; in jwk) === false)
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RS1&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RS256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RS384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RS512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion

								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						case &quot;ECDSA&quot;:
							keyUsages = [&quot;sign&quot;]; // Override existing keyUsages value since the key is a private key
							// break omitted
						case &quot;ECDH&quot;:
							{
								//region Initial variables
								jwk = {
									kty: &quot;EC&quot;,
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about used hash function
								if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== &quot;1.2.840.10045.2.1&quot;)
									return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						case &quot;RSA-OAEP&quot;:
							{
								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								
								//region Get information about used hash function
								if(this.name.toLowerCase() === &quot;safari&quot;)
									jwk.alg = &quot;RSA-OAEP&quot;;
								else
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RSA-OAEP&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RSA-OAEP-256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RSA-OAEP-384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RSA-OAEP-512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion
								
								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();
								
								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case &quot;jwk&quot;:
				jwk = keyData;
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}
		
		//region Special case for Safari browser (since its acting not as WebCrypto standard describes)
		if(this.name.toLowerCase() === &quot;safari&quot;)
		{
			// Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)
			return Promise.resolve().then(() =&gt; this.subtle.importKey(&quot;jwk&quot;, stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages))
				.then(result =&gt; result, () =&gt; this.subtle.importKey(&quot;jwk&quot;, jwk, algorithm, extractable, keyUsages));
		}
		//endregion
		
		return this.subtle.importKey(&quot;jwk&quot;, jwk, algorithm, extractable, keyUsages);
	}
	//**********************************************************************************
	/**
	 * Export WebCrypto keys to different formats
	 * @param {string} format
	 * @param {Object} key
	 * @returns {Promise}
	 */
	exportKey(format, key)
	{
		let sequence = this.subtle.exportKey(&quot;jwk&quot;, key);
		
		//region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation
		if(this.name.toLowerCase() === &quot;safari&quot;)
		{
			sequence = sequence.then(result =&gt;
			{
				// Some additional checks for Safari Technology Preview
				if(result instanceof ArrayBuffer)
					return JSON.parse(arrayBufferToString(result));
				
				return result;
			});
		}
		//endregion
		
		switch(format.toLowerCase())
		{
			case &quot;raw&quot;:
				return this.subtle.exportKey(&quot;raw&quot;, key);
			case &quot;spki&quot;:
				sequence = sequence.then(result =&gt;
				{
					const publicKeyInfo = new PublicKeyInfo();

					try
					{
						publicKeyInfo.fromJSON(result);
					}
					catch(ex)
					{
						return Promise.reject(&quot;Incorrect key data&quot;);
					}

					return publicKeyInfo.toSchema().toBER(false);
				});
				break;
			case &quot;pkcs8&quot;:
				sequence = sequence.then(result =&gt;
				{
					const privateKeyInfo = new PrivateKeyInfo();

					try
					{
						privateKeyInfo.fromJSON(result);
					}
					catch(ex)
					{
						return Promise.reject(&quot;Incorrect key data&quot;);
					}

					return privateKeyInfo.toSchema().toBER(false);
				});
				break;
			case &quot;jwk&quot;:
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}

		return sequence;
	}
	//**********************************************************************************
	/**
	 * Convert WebCrypto keys between different export formats
	 * @param {string} inputFormat
	 * @param {string} outputFormat
	 * @param {ArrayBuffer|Object} keyData
	 * @param {Object} algorithm
	 * @param {boolean} extractable
	 * @param {Array} keyUsages
	 * @returns {Promise}
	 */
	convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages)
	{
		switch(inputFormat.toLowerCase())
		{
			case &quot;raw&quot;:
				switch(outputFormat.toLowerCase())
				{
					case &quot;raw&quot;:
						return Promise.resolve(keyData);
					case &quot;spki&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;spki&quot;, result));
					case &quot;pkcs8&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;pkcs8&quot;, result));
					case &quot;jwk&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;spki&quot;:
				switch(outputFormat.toLowerCase())
				{
					case &quot;raw&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;spki&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.resolve(keyData);
					case &quot;pkcs8&quot;:
						return Promise.reject(&quot;Impossible to convert between SPKI/PKCS8&quot;);
					case &quot;jwk&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;spki&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;pkcs8&quot;:
				switch(outputFormat.toLowerCase())
				{
					case &quot;raw&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;pkcs8&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.reject(&quot;Impossible to convert between SPKI/PKCS8&quot;);
					case &quot;pkcs8&quot;:
						return Promise.resolve(keyData);
					case &quot;jwk&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;pkcs8&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;jwk&quot;:
				switch(outputFormat.toLowerCase())
				{
					case &quot;raw&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;spki&quot;, result));
					case &quot;pkcs8&quot;:
						return Promise.resolve()
							.then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages))
							.then(result =&gt; this.exportKey(&quot;pkcs8&quot;, result));
					case &quot;jwk&quot;:
						return Promise.resolve(keyData);
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			default:
				return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);
		}
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;encrypt&quot;
	 * @param args
	 * @returns {Promise}
	 */
	encrypt(...args)
	{
		return this.subtle.encrypt(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;decrypt&quot;
	 * @param args
	 * @returns {Promise}
	 */
	decrypt(...args)
	{
		return this.subtle.decrypt(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;sign&quot;
	 * @param args
	 * @returns {Promise}
	 */
	sign(...args)
	{
		return this.subtle.sign(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;verify&quot;
	 * @param args
	 * @returns {Promise}
	 */
	verify(...args)
	{
		return this.subtle.verify(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;digest&quot;
	 * @param args
	 * @returns {Promise}
	 */
	digest(...args)
	{
		return this.subtle.digest(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;generateKey&quot;
	 * @param args
	 * @returns {Promise}
	 */
	generateKey(...args)
	{
		return this.subtle.generateKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;deriveKey&quot;
	 * @param args
	 * @returns {Promise}
	 */
	deriveKey(...args)
	{
		return this.subtle.deriveKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;deriveBits&quot;
	 * @param args
	 * @returns {Promise}
	 */
	deriveBits(...args)
	{
		return this.subtle.deriveBits(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;wrapKey&quot;
	 * @param args
	 * @returns {Promise}
	 */
	wrapKey(...args)
	{
		return this.subtle.wrapKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function &quot;unwrapKey&quot;
	 * @param args
	 * @returns {Promise}
	 */
	unwrapKey(...args)
	{
		return this.subtle.unwrapKey(...args);
	}
	//**********************************************************************************
	/**
	 * Initialize input Uint8Array by random values (with help from current &quot;crypto engine&quot;)
	 * @param {!Uint8Array} view
	 * @returns {*}
	 */
	getRandomValues(view)
	{
		if((&quot;getRandomValues&quot; in this.crypto) === false)
			throw new Error(&quot;No support for getRandomValues&quot;);
		
		return this.crypto.getRandomValues(view);
	}
	//**********************************************************************************
	/**
	 * Get WebCrypto algorithm by wel-known OID
	 * @param {string} oid well-known OID to search for
	 * @returns {Object}
	 */
	getAlgorithmByOID(oid)
	{
		switch(oid)
		{
			case &quot;1.2.840.113549.1.1.1&quot;:
			case &quot;1.2.840.113549.1.1.5&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.11&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.12&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.13&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.10&quot;:
				return {
					name: &quot;RSA-PSS&quot;
				};
			case &quot;1.2.840.113549.1.1.7&quot;:
				return {
					name: &quot;RSA-OAEP&quot;
				};
			case &quot;1.2.840.10045.2.1&quot;:
			case &quot;1.2.840.10045.4.1&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.2&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.3&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.4&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.3.133.16.840.63.0.2&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-1&quot;
				};
			case &quot;1.3.132.1.11.1&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-256&quot;
				};
			case &quot;1.3.132.1.11.2&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-384&quot;
				};
			case &quot;1.3.132.1.11.3&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-512&quot;
				};
			case &quot;2.16.840.1.101.3.4.1.2&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.22&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.42&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.6&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.26&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.46&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.4&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.24&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.44&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.5&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.25&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.45&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 256
				};
			case &quot;1.2.840.113549.2.7&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.113549.2.9&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.113549.2.10&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.113549.2.11&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.2.840.113549.1.9.16.3.5&quot;:
				return {
					name: &quot;DH&quot;
				};
			case &quot;1.3.14.3.2.26&quot;:
				return {
					name: &quot;SHA-1&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.1&quot;:
				return {
					name: &quot;SHA-256&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.2&quot;:
				return {
					name: &quot;SHA-384&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.3&quot;:
				return {
					name: &quot;SHA-512&quot;
				};
			case &quot;1.2.840.113549.1.5.12&quot;:
				return {
					name: &quot;PBKDF2&quot;
				};
			//region Special case - OIDs for ECC curves
			case &quot;1.2.840.10045.3.1.7&quot;:
				return {
					name: &quot;P-256&quot;
				};
			case &quot;1.3.132.0.34&quot;:
				return {
					name: &quot;P-384&quot;
				};
			case &quot;1.3.132.0.35&quot;:
				return {
					name: &quot;P-521&quot;
				};
			//endregion
			default:
		}
		
		return {};
	}
	//**********************************************************************************
	/**
	 * Get OID for each specific algorithm
	 * @param {Object} algorithm
	 * @returns {string}
	 */
	getOIDByAlgorithm(algorithm)
	{
		let result = &quot;&quot;;
		
		switch(algorithm.name.toUpperCase())
		{
			case &quot;RSASSA-PKCS1-V1_5&quot;:
				switch(algorithm.hash.name.toUpperCase())
				{
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.113549.1.1.5&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.113549.1.1.11&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.113549.1.1.12&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.113549.1.1.13&quot;;
						break;
					default:
				}
				break;
			case &quot;RSA-PSS&quot;:
				result = &quot;1.2.840.113549.1.1.10&quot;;
				break;
			case &quot;RSA-OAEP&quot;:
				result = &quot;1.2.840.113549.1.1.7&quot;;
				break;
			case &quot;ECDSA&quot;:
				switch(algorithm.hash.name.toUpperCase())
				{
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.10045.4.1&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.10045.4.3.2&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.10045.4.3.3&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.10045.4.3.4&quot;;
						break;
					default:
				}
				break;
			case &quot;ECDH&quot;:
				switch(algorithm.kdf.toUpperCase()) // Non-standard addition - hash algorithm of KDF function
				{
					case &quot;SHA-1&quot;:
						result = &quot;1.3.133.16.840.63.0.2&quot;; // dhSinglePass-stdDH-sha1kdf-scheme
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.3.132.1.11.1&quot;; // dhSinglePass-stdDH-sha256kdf-scheme
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.3.132.1.11.2&quot;; // dhSinglePass-stdDH-sha384kdf-scheme
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.3.132.1.11.3&quot;; // dhSinglePass-stdDH-sha512kdf-scheme
						break;
					default:
				}
				break;
			case &quot;AES-CTR&quot;:
				break;
			case &quot;AES-CBC&quot;:
				switch(algorithm.length)
				{
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.2&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.22&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.42&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-CMAC&quot;:
				break;
			case &quot;AES-GCM&quot;:
				switch(algorithm.length)
				{
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.6&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.26&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.46&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-CFB&quot;:
				switch(algorithm.length)
				{
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.4&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.24&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.44&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-KW&quot;:
				switch(algorithm.length)
				{
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.5&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.25&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.45&quot;;
						break;
					default:
				}
				break;
			case &quot;HMAC&quot;:
				switch(algorithm.hash.name.toUpperCase())
				{
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.113549.2.7&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.113549.2.9&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.113549.2.10&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.113549.2.11&quot;;
						break;
					default:
				}
				break;
			case &quot;DH&quot;:
				result = &quot;1.2.840.113549.1.9.16.3.5&quot;;
				break;
			case &quot;SHA-1&quot;:
				result = &quot;1.3.14.3.2.26&quot;;
				break;
			case &quot;SHA-256&quot;:
				result = &quot;2.16.840.1.101.3.4.2.1&quot;;
				break;
			case &quot;SHA-384&quot;:
				result = &quot;2.16.840.1.101.3.4.2.2&quot;;
				break;
			case &quot;SHA-512&quot;:
				result = &quot;2.16.840.1.101.3.4.2.3&quot;;
				break;
			case &quot;CONCAT&quot;:
				break;
			case &quot;HKDF&quot;:
				break;
			case &quot;PBKDF2&quot;:
				result = &quot;1.2.840.113549.1.5.12&quot;;
				break;
			//region Special case - OIDs for ECC curves
			case &quot;P-256&quot;:
				result = &quot;1.2.840.10045.3.1.7&quot;;
				break;
			case &quot;P-384&quot;:
				result = &quot;1.3.132.0.34&quot;;
				break;
			case &quot;P-521&quot;:
				result = &quot;1.3.132.0.35&quot;;
				break;
			//endregion
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Get default algorithm parameters for each kind of operation
	 * @param {string} algorithmName Algorithm name to get common parameters for
	 * @param {string} operation Kind of operation: &quot;sign&quot;, &quot;encrypt&quot;, &quot;generatekey&quot;, &quot;importkey&quot;, &quot;exportkey&quot;, &quot;verify&quot;
	 * @returns {*}
	 */
	getAlgorithmParameters(algorithmName, operation)
	{
		let result = {
			algorithm: {},
			usages: []
		};
		
		switch(algorithmName.toUpperCase())
		{
			case &quot;RSASSA-PKCS1-V1_5&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;verify&quot;:
					case &quot;sign&quot;:
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;verify&quot;] // For importKey(&quot;pkcs8&quot;) usage must be &quot;sign&quot; only
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;RSA-PSS&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;sign&quot;:
					case &quot;verify&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								hash: {
									name: &quot;SHA-1&quot;
								},
								saltLength: 20
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-1&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								hash: {
									name: &quot;SHA-1&quot;
								}
							},
							usages: [&quot;verify&quot;] // For importKey(&quot;pkcs8&quot;) usage must be &quot;sign&quot; only
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSA-PSS&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;RSA-OAEP&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;encrypt&quot;:
					case &quot;decrypt&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;encrypt&quot;] // encrypt for &quot;spki&quot; and decrypt for &quot;pkcs8&quot;
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSA-OAEP&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;ECDSA&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;verify&quot;] // &quot;sign&quot; for &quot;pkcs8&quot;
						};
						break;
					case &quot;verify&quot;:
					case &quot;sign&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;ECDSA&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;ECDH&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;exportkey&quot;:
					case &quot;importkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDH&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;deriveKey&quot;, &quot;deriveBits&quot;]
						};
						break;
					case &quot;derivekey&quot;:
					case &quot;derivebits&quot;:
						result = {
							algorithm: {
								name: &quot;ECDH&quot;,
								namedCurve: &quot;P-256&quot;,
								public: [] // Must be a &quot;publicKey&quot;
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;ECDH&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-CTR&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CTR&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CTR&quot;,
								counter: new Uint8Array(16),
								length: 10
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-CTR&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-CBC&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CBC&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CBC&quot;,
								iv: this.getRandomValues(new Uint8Array(16)) // For &quot;decrypt&quot; the value should be replaced with value got on &quot;encrypt&quot; step
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-CBC&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-GCM&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-GCM&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-GCM&quot;,
								iv: this.getRandomValues(new Uint8Array(16)) // For &quot;decrypt&quot; the value should be replaced with value got on &quot;encrypt&quot; step
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-GCM&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-KW&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
					case &quot;wrapkey&quot;:
					case &quot;unwrapkey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-KW&quot;,
								length: 256
							},
							usages: [&quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-KW&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;HMAC&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;sign&quot;:
					case &quot;verify&quot;:
						result = {
							algorithm: {
								name: &quot;HMAC&quot;
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;HMAC&quot;,
								length: 32,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;HMAC&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;HKDF&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;derivekey&quot;:
						result = {
							algorithm: {
								name: &quot;HKDF&quot;,
								hash: &quot;SHA-256&quot;,
								salt: new Uint8Array([]),
								info: new Uint8Array([])
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;HKDF&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;PBKDF2&quot;:
				switch(operation.toLowerCase())
				{
					case &quot;derivekey&quot;:
						result = {
							algorithm: {
								name: &quot;PBKDF2&quot;,
								hash: { name: &quot;SHA-256&quot; },
								salt: new Uint8Array([]),
								iterations: 10000
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;PBKDF2&quot;
							},
							usages: []
						};
				}
				break;
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Getting hash algorithm by signature algorithm
	 * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
	 * @returns {string}
	 */
	getHashAlgorithm(signatureAlgorithm)
	{
		let result = &quot;&quot;;
		
		switch(signatureAlgorithm.algorithmId)
		{
			case &quot;1.2.840.10045.4.1&quot;: // ecdsa-with-SHA1
			case &quot;1.2.840.113549.1.1.5&quot;:
				result = &quot;SHA-1&quot;;
				break;
			case &quot;1.2.840.10045.4.3.2&quot;: // ecdsa-with-SHA256
			case &quot;1.2.840.113549.1.1.11&quot;:
				result = &quot;SHA-256&quot;;
				break;
			case &quot;1.2.840.10045.4.3.3&quot;: // ecdsa-with-SHA384
			case &quot;1.2.840.113549.1.1.12&quot;:
				result = &quot;SHA-384&quot;;
				break;
			case &quot;1.2.840.10045.4.3.4&quot;: // ecdsa-with-SHA512
			case &quot;1.2.840.113549.1.1.13&quot;:
				result = &quot;SHA-512&quot;;
				break;
			case &quot;1.2.840.113549.1.1.10&quot;: // RSA-PSS
				{
					try
					{
						const params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
						if(&quot;hashAlgorithm&quot; in params)
						{
							const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
							if((&quot;name&quot; in algorithm) === false)
								return &quot;&quot;;
							
							result = algorithm.name;
						}
						else
							result = &quot;SHA-1&quot;;
					}
					catch(ex)
					{
					}
				}
				break;
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Specialized function encrypting &quot;EncryptedContentInfo&quot; object using parameters
	 * @param {Object} parameters
	 * @returns {Promise}
	 */
	encryptEncryptedContentInfo(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);
		
		if((&quot;password&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
		
		if((&quot;contentEncryptionAlgorithm&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;contentEncryptionAlgorithm\&quot;&quot;);
		
		if((&quot;hmacHashAlgorithm&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;hmacHashAlgorithm\&quot;&quot;);
		
		if((&quot;iterationCount&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);
		
		if((&quot;contentToEncrypt&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToEncrypt\&quot;&quot;);
		
		if((&quot;contentType&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;contentType\&quot;&quot;);

		const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
		if(contentEncryptionOID === &quot;&quot;)
			return Promise.reject(&quot;Wrong \&quot;contentEncryptionAlgorithm\&quot; value&quot;);
		
		const pbkdf2OID = this.getOIDByAlgorithm({
			name: &quot;PBKDF2&quot;
		});
		if(pbkdf2OID === &quot;&quot;)
			return Promise.reject(&quot;Can not find OID for PBKDF2&quot;);
		
		const hmacOID = this.getOIDByAlgorithm({
			name: &quot;HMAC&quot;,
			hash: {
				name: parameters.hmacHashAlgorithm
			}
		});
		if(hmacOID === &quot;&quot;)
			return Promise.reject(`Incorrect value for &quot;hmacHashAlgorithm&quot;: ${parameters.hmacHashAlgorithm}`);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		this.getRandomValues(ivView);
		
		const saltBuffer = new ArrayBuffer(64);
		const saltView = new Uint8Array(saltBuffer);
		this.getRandomValues(saltView);
		
		const contentView = new Uint8Array(parameters.contentToEncrypt);
		
		const pbkdf2Params = new PBKDF2Params({
			salt: new asn1js.OctetString({ valueHex: saltBuffer }),
			iterationCount: parameters.iterationCount,
			prf: new AlgorithmIdentifier({
				algorithmId: hmacOID,
				algorithmParams: new asn1js.Null()
			})
		});
		//endregion
		
		//region Derive PBKDF2 key from &quot;password&quot; buffer
		sequence = sequence.then(() =&gt;
		{
			const passwordView = new Uint8Array(parameters.password);
			
			return this.importKey(&quot;raw&quot;,
				passwordView,
				&quot;PBKDF2&quot;,
				false,
				[&quot;deriveKey&quot;]);
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Derive key for &quot;contentEncryptionAlgorithm&quot;
		sequence = sequence.then(result =&gt;
			this.deriveKey({
				name: &quot;PBKDF2&quot;,
				hash: {
					name: parameters.hmacHashAlgorithm
				},
				salt: saltView,
				iterations: parameters.iterationCount
			},
			result,
			parameters.contentEncryptionAlgorithm,
			false,
			[&quot;encrypt&quot;]),
		error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Encrypt content
		sequence = sequence.then(result =&gt;
			this.encrypt({
				name: parameters.contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			contentView),
		error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Store all parameters in EncryptedData object
		sequence = sequence.then(result =&gt;
		{
			const pbes2Parameters = new PBES2Params({
				keyDerivationFunc: new AlgorithmIdentifier({
					algorithmId: pbkdf2OID,
					algorithmParams: pbkdf2Params.toSchema()
				}),
				encryptionScheme: new AlgorithmIdentifier({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
				})
			});
			
			return new EncryptedContentInfo({
				contentType: parameters.contentType,
				contentEncryptionAlgorithm: new AlgorithmIdentifier({
					algorithmId: &quot;1.2.840.113549.1.5.13&quot;, // pkcs5PBES2
					algorithmParams: pbes2Parameters.toSchema()
				}),
				encryptedContent: new asn1js.OctetString({ valueHex: result })
			});
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
	 * Decrypt data stored in &quot;EncryptedContentInfo&quot; object using parameters
	 * @param parameters
	 * @return {Promise}
	 */
	decryptEncryptedContentInfo(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);
		
		if((&quot;password&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
		
		if((&quot;encryptedContentInfo&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;encryptedContentInfo\&quot;&quot;);

		if(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== &quot;1.2.840.113549.1.5.13&quot;) // pkcs5PBES2
			return Promise.reject(`Unknown &quot;contentEncryptionAlgorithm&quot;: ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		let pbes2Parameters;
		
		try
		{
			pbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
		}
		catch(ex)
		{
			return Promise.reject(&quot;Incorrectly encoded \&quot;pbes2Parameters\&quot;&quot;);
		}
		
		let pbkdf2Params;
		
		try
		{
			pbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
		}
		catch(ex)
		{
			return Promise.reject(&quot;Incorrectly encoded \&quot;pbkdf2Params\&quot;&quot;);
		}
		
		const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
		if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
			return Promise.reject(`Incorrect OID for &quot;contentEncryptionAlgorithm&quot;: ${pbes2Parameters.encryptionScheme.algorithmId}`);
		
		const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
		const ivView = new Uint8Array(ivBuffer);
		
		const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
		const saltView = new Uint8Array(saltBuffer);
		
		const iterationCount = pbkdf2Params.iterationCount;
		
		let hmacHashAlgorithm = &quot;SHA-1&quot;;
		
		if(&quot;prf&quot; in pbkdf2Params)
		{
			const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
			if((&quot;name&quot; in algorithm) === false)
				return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);
			
			hmacHashAlgorithm = algorithm.hash.name;
		}
		//endregion
		
		//region Derive PBKDF2 key from &quot;password&quot; buffer
		sequence = sequence.then(() =&gt;
			this.importKey(&quot;raw&quot;,
				parameters.password,
				&quot;PBKDF2&quot;,
				false,
				[&quot;deriveKey&quot;]),
		error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Derive key for &quot;contentEncryptionAlgorithm&quot;
		sequence = sequence.then(result =&gt;
			this.deriveKey({
				name: &quot;PBKDF2&quot;,
				hash: {
					name: hmacHashAlgorithm
				},
				salt: saltView,
				iterations: iterationCount
			},
			result,
			contentEncryptionAlgorithm,
			false,
			[&quot;decrypt&quot;]),
		error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Decrypt internal content using derived key
		sequence = sequence.then(result =&gt;
		{
			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);
			
			if(parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)
				dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
			else
			{
				for(const content of parameters.encryptedContentInfo.encryptedContent.valueBlock.value)
					dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);
			}
			//endregion
			
			return this.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			dataBuffer);
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Stamping (signing) data using algorithm simular to HMAC
	 * @param {Object} parameters
	 * @return {Promise.&lt;T&gt;|Promise}
	 */
	stampDataWithPassword(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);
		
		if((&quot;password&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
		
		if((&quot;hashAlgorithm&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;hashAlgorithm\&quot;&quot;);
		
		if((&quot;salt&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);
		
		if((&quot;iterationCount&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;salt\&quot;&quot;);
		
		if((&quot;contentToStamp&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToStamp\&quot;&quot;);
		//endregion
		
		//region Choose correct length for HMAC key
		let length;
		
		switch(parameters.hashAlgorithm.toLowerCase())
		{
			case &quot;sha-1&quot;:
				length = 160;
				break;
			case &quot;sha-256&quot;:
				length = 256;
				break;
			case &quot;sha-384&quot;:
				length = 384;
				break;
			case &quot;sha-512&quot;:
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect &quot;parameters.hashAlgorithm&quot; parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const hmacAlgorithm = {
			name: &quot;HMAC&quot;,
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion

		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() =&gt; makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion
		
		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(
			result =&gt;
				this.importKey(&quot;raw&quot;,
					new Uint8Array(result),
					hmacAlgorithm,
					false,
					[&quot;sign&quot;])
		);
		//endregion
		
		//region Make signed HMAC value
		sequence = sequence.then(
			result =&gt;
				this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)),
			error =&gt; Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
	verifyDataStampedWithPassword(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);
		
		if((&quot;password&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
		
		if((&quot;hashAlgorithm&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;hashAlgorithm\&quot;&quot;);
		
		if((&quot;salt&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);
		
		if((&quot;iterationCount&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;salt\&quot;&quot;);
		
		if((&quot;contentToVerify&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToVerify\&quot;&quot;);
		
		if((&quot;signatureToVerify&quot; in parameters) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;signatureToVerify\&quot;&quot;);
		//endregion
		
		//region Choose correct length for HMAC key
		let length;
		
		switch(parameters.hashAlgorithm.toLowerCase())
		{
			case &quot;sha-1&quot;:
				length = 160;
				break;
			case &quot;sha-256&quot;:
				length = 256;
				break;
			case &quot;sha-384&quot;:
				length = 384;
				break;
			case &quot;sha-512&quot;:
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect &quot;parameters.hashAlgorithm&quot; parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const hmacAlgorithm = {
			name: &quot;HMAC&quot;,
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion
		
		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() =&gt; makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion
		
		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(result =&gt;
			this.importKey(&quot;raw&quot;,
				new Uint8Array(result),
				hmacAlgorithm,
				false,
				[&quot;verify&quot;])
		);
		//endregion
		
		//region Make signed HMAC value
		sequence = sequence.then(
			result =&gt;
				this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)),
			error =&gt; Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Get signature parameters by analyzing private key algorithm
	 * @param {Object} privateKey The private key user would like to use
	 * @param {string} [hashAlgorithm=&quot;SHA-1&quot;] Hash algorithm user would like to use
	 * @return {Promise.&lt;T&gt;|Promise}
	 */
	getSignatureParameters(privateKey, hashAlgorithm = &quot;SHA-1&quot;)
	{
		//region Check hashing algorithm
		const oid = this.getOIDByAlgorithm({ name: hashAlgorithm });
		if(oid === &quot;&quot;)
			return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion
		
		//region Initial variables
		const signatureAlgorithm = new AlgorithmIdentifier();
		//endregion
		
		//region Get a &quot;default parameters&quot; for current algorithm
		const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, &quot;sign&quot;);
		parameters.algorithm.hash.name = hashAlgorithm;
		//endregion
		
		//region Fill internal structures base on &quot;privateKey&quot; and &quot;hashAlgorithm&quot;
		switch(privateKey.algorithm.name.toUpperCase())
		{
			case &quot;RSASSA-PKCS1-V1_5&quot;:
			case &quot;ECDSA&quot;:
				signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
				break;
			case &quot;RSA-PSS&quot;:
				{
					//region Set &quot;saltLength&quot; as a length (in octets) of hash function result
					switch(hashAlgorithm.toUpperCase())
					{
						case &quot;SHA-256&quot;:
							parameters.algorithm.saltLength = 32;
							break;
						case &quot;SHA-384&quot;:
							parameters.algorithm.saltLength = 48;
							break;
						case &quot;SHA-512&quot;:
							parameters.algorithm.saltLength = 64;
							break;
						default:
					}
					//endregion
					
					//region Fill &quot;RSASSA_PSS_params&quot; object
					const paramsObject = {};
					
					if(hashAlgorithm.toUpperCase() !== &quot;SHA-1&quot;)
					{
						const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm });
						if(hashAlgorithmOID === &quot;&quot;)
							return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
						
						paramsObject.hashAlgorithm = new AlgorithmIdentifier({
							algorithmId: hashAlgorithmOID,
							algorithmParams: new asn1js.Null()
						});
						
						paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
							algorithmId: &quot;1.2.840.113549.1.1.8&quot;, // MGF1
							algorithmParams: paramsObject.hashAlgorithm.toSchema()
						});
					}
					
					if(parameters.algorithm.saltLength !== 20)
						paramsObject.saltLength = parameters.algorithm.saltLength;
					
					const pssParameters = new RSASSAPSSParams(paramsObject);
					//endregion
					
					//region Automatically set signature algorithm
					signatureAlgorithm.algorithmId = &quot;1.2.840.113549.1.1.10&quot;;
					signatureAlgorithm.algorithmParams = pssParameters.toSchema();
					//endregion
				}
				break;
			default:
				return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
		}
		//endregion

		return Promise.resolve().then(() =&gt; ({
			signatureAlgorithm,
			parameters
		}));
	}
	//**********************************************************************************
	/**
	 * Sign data with pre-defined private key
	 * @param {ArrayBuffer} data Data to be signed
	 * @param {Object} privateKey Private key to use
	 * @param {Object} parameters Parameters for used algorithm
	 * @return {Promise.&lt;T&gt;|Promise}
	 */
	signWithPrivateKey(data, privateKey, parameters)
	{
		return this.sign(parameters.algorithm,
			privateKey,
			new Uint8Array(data))
			.then(result =&gt;
			{
				//region Special case for ECDSA algorithm
				if(parameters.algorithm.name === &quot;ECDSA&quot;)
					result = createCMSECDSASignature(result);
				//endregion
				
				return result;
			}, error =&gt;
				Promise.reject(`Signing error: ${error}`)
			);
	}
	//**********************************************************************************
	fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm)
	{
		const parameters = {};
		
		//region Find signer&apos;s hashing algorithm
		const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
		if(shaAlgorithm === &quot;&quot;)
			return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
		//endregion
		
		//region Get information about public key algorithm and default parameters for import
		let algorithmId;
		if(signatureAlgorithm.algorithmId === &quot;1.2.840.113549.1.1.10&quot;)
			algorithmId = signatureAlgorithm.algorithmId;
		else
			algorithmId = publicKeyInfo.algorithm.algorithmId;
		
		const algorithmObject = this.getAlgorithmByOID(algorithmId);
		if((&quot;name&quot; in algorithmObject) === &quot;&quot;)
			return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
		
		parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, &quot;importkey&quot;);
		if(&quot;hash&quot; in parameters.algorithm.algorithm)
			parameters.algorithm.algorithm.hash.name = shaAlgorithm;
		
		//region Special case for ECDSA
		if(algorithmObject.name === &quot;ECDSA&quot;)
		{
			//region Get information about named curve
			let algorithmParamsChecked = false;
			
			if((&quot;algorithmParams&quot; in publicKeyInfo.algorithm) === true)
			{
				if(&quot;idBlock&quot; in publicKeyInfo.algorithm.algorithmParams)
				{
					if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) &amp;&amp; (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
						algorithmParamsChecked = true;
				}
			}
			
			if(algorithmParamsChecked === false)
				return Promise.reject(&quot;Incorrect type for ECDSA public key parameters&quot;);
			
			const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
			if((&quot;name&quot; in curveObject) === false)
				return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
			//endregion
			
			parameters.algorithm.algorithm.namedCurve = curveObject.name;
		}
		//endregion
		//endregion
		
		return parameters;
	}
	//**********************************************************************************
	getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null)
	{
		if(parameters === null)
			parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
		
		const publicKeyInfoSchema = publicKeyInfo.toSchema();
		const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
		const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);
		
		return this.importKey(&quot;spki&quot;,
			publicKeyInfoView,
			parameters.algorithm.algorithm,
			true,
			parameters.algorithm.usages
		);
	}
	//**********************************************************************************
	verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion
		
		//region Find signer&apos;s hashing algorithm
		if(shaAlgorithm === null)
		{
			shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
			if(shaAlgorithm === &quot;&quot;)
				return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
			
			//region Import public key
			sequence = sequence.then(() =&gt;
				this.getPublicKey(publicKeyInfo, signatureAlgorithm));
			//endregion
		}
		else
		{
			const parameters = {};
			
			//region Get information about public key algorithm and default parameters for import
			let algorithmId;
			if(signatureAlgorithm.algorithmId === &quot;1.2.840.113549.1.1.10&quot;)
				algorithmId = signatureAlgorithm.algorithmId;
			else
				algorithmId = publicKeyInfo.algorithm.algorithmId;
			
			const algorithmObject = this.getAlgorithmByOID(algorithmId);
			if((&quot;name&quot; in algorithmObject) === &quot;&quot;)
				return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
			
			parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, &quot;importkey&quot;);
			if(&quot;hash&quot; in parameters.algorithm.algorithm)
				parameters.algorithm.algorithm.hash.name = shaAlgorithm;
			
			//region Special case for ECDSA
			if(algorithmObject.name === &quot;ECDSA&quot;)
			{
				//region Get information about named curve
				let algorithmParamsChecked = false;
				
				if((&quot;algorithmParams&quot; in publicKeyInfo.algorithm) === true)
				{
					if(&quot;idBlock&quot; in publicKeyInfo.algorithm.algorithmParams)
					{
						if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) &amp;&amp; (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
							algorithmParamsChecked = true;
					}
				}
				
				if(algorithmParamsChecked === false)
					return Promise.reject(&quot;Incorrect type for ECDSA public key parameters&quot;);
				
				const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
				if((&quot;name&quot; in curveObject) === false)
					return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
				//endregion
				
				parameters.algorithm.algorithm.namedCurve = curveObject.name;
			}
			//endregion
			//endregion

			//region Import public key
			sequence = sequence.then(() =&gt;
				this.getPublicKey(publicKeyInfo, null, parameters));
			//endregion
		}
		//endregion
		
		//region Verify signature
		sequence = sequence.then(publicKey =&gt;
		{
			//region Get default algorithm parameters for verification
			const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, &quot;verify&quot;);
			if(&quot;hash&quot; in algorithm.algorithm)
				algorithm.algorithm.hash.name = shaAlgorithm;
			//endregion
			
			//region Special case for ECDSA signatures
			let signatureValue = signature.valueBlock.valueHex;
			
			if(publicKey.algorithm.name === &quot;ECDSA&quot;)
			{
				const asn1 = asn1js.fromBER(signatureValue);
				// noinspection JSCheckFunctionSignatures
				signatureValue = createECDSASignatureFromCMS(asn1.result);
			}
			//endregion
			
			//region Special case for RSA-PSS
			if(publicKey.algorithm.name === &quot;RSA-PSS&quot;)
			{
				let pssParameters;
				
				try
				{
					pssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject(ex);
				}
				
				if(&quot;saltLength&quot; in pssParameters)
					algorithm.algorithm.saltLength = pssParameters.saltLength;
				else
					algorithm.algorithm.saltLength = 20;
				
				let hashAlgo = &quot;SHA-1&quot;;
				
				if(&quot;hashAlgorithm&quot; in pssParameters)
				{
					const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
					if((&quot;name&quot; in hashAlgorithm) === false)
						return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);
					
					hashAlgo = hashAlgorithm.name;
				}
				
				algorithm.algorithm.hash.name = hashAlgo;
			}
			//endregion
			
			return this.verify(algorithm.algorithm,
				publicKey,
				new Uint8Array(signatureValue),
				new Uint8Array(data)
			);
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
